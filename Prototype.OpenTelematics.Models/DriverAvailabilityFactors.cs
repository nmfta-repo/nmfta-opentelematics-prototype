using System;
using System.Collections.Generic;
using System.Text;

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Prototype.OpenTelematics.Models;
//
//    var coordinate = Coordinate.FromJson(jsonString);

namespace Prototype.OpenTelematics.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class DriverAvailability
    {
        /// <summary>
        /// The Coarse Vehicle Location Time History associated with the requested `driverId` for the
        /// requested time period [`start`, `stop`)
        /// </summary>
        [JsonProperty("coarseVehicleLocationTimeHistory", Required = Required.Always)]
        public CoarseVehicleLocationTimeHistory CoarseVehicleLocationTimeHistory { get; set; }

        /// <summary>
        /// The Duty Status Logs of the requested `driverId` for the requested time period [`start`,
        /// `stop`)
        /// </summary>
        [JsonProperty("dutyStatusLogs", Required = Required.Always)]
        public DutyStatusLog[] DutyStatusLogs { get; set; }

        /// <summary>
        /// All Vehicle Flagged Events which are associated with the requested `driverId` and which
        /// occur within the requested time period [`start`, `stop`)
        /// </summary>
        [JsonProperty("vehicleFlaggedEvents", Required = Required.Always)]
        public VehicleFlaggedEvent[] VehicleFlaggedEvents { get; set; }
    }

    /// <summary>
    /// The Coarse Vehicle Location Time History associated with the requested `driverId` for the
    /// requested time period [`start`, `stop`)
    /// </summary>
    public partial class CoarseVehicleLocationTimeHistory
    {
        /// <summary>
        /// array of Location Times representing the vehicle's location over time.
        /// </summary>
        [JsonProperty("data", Required = Required.Always)]
        public Datum[] Data { get; set; }

        /// <summary>
        /// a status variable to indicate if this time history has a higher available resolution at
        /// the TSP
        /// </summary>
        [JsonProperty("timeResolution", Required = Required.Always)]
        public TimeResolution TimeResolution { get; set; }
    }

    public partial class Datum
    {
        /// <summary>
        /// time
        /// </summary>
        [JsonProperty("dateTime", Required = Required.Always)]
        public string DateTime { get; set; }

        /// <summary>
        /// The unique identifier for the specific Entity object in the system.
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// location
        /// </summary>
        [JsonProperty("location", Required = Required.Always)]
        public string Location { get; set; }

        /// <summary>
        /// The unique 'Provider ID' of the TSP.
        /// </summary>
        [JsonProperty("providerId", Required = Required.Always)]
        public string ProviderId { get; set; }

        /// <summary>
        /// The vehicle id associated with this Location Time
        /// </summary>
        [JsonProperty("vehicleId", Required = Required.Always)]
        public string VehicleId { get; set; }
    }

    public partial class DutyStatusLog
    {
        /// <summary>
        /// The list of AnnotationLog(s) which are associated with this log.
        /// </summary>
        [JsonProperty("annotations", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Annotation[] Annotations { get; set; }

        /// <summary>
        /// The list of the co-driver User(s) for this log.
        /// </summary>
        [JsonProperty("coDrivers", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string[] CoDrivers { get; set; }

        /// <summary>
        /// Date and time from the telematics device
        /// </summary>
        [JsonProperty("dateTime", Required = Required.Always)]
        public string DateTime { get; set; }

        /// <summary>
        /// The distance in whole miles traveled since the last valid latitude, longitude pair the
        /// ELD measured with required accuracy in the ELD mandate
        /// </summary>
        [JsonProperty("distanceLastValid", Required = Required.Always)]
        public double DistanceLastValid { get; set; }

        /// <summary>
        /// The id of the driver who created this log.
        /// </summary>
        [JsonProperty("driverId", Required = Required.Always)]
        public string DriverId { get; set; }

        /// <summary>
        /// The date and time the log was edited. If the log has not been edited, this will not be
        /// set.
        /// </summary>
        [JsonProperty("editDateTime", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string EditDateTime { get; set; }

        /// <summary>
        /// The record status number of this log
        /// </summary>
        [JsonProperty("eventRecordStatus", Required = Required.Always)]
        public EventRecordStatus EventRecordStatus { get; set; }

        /// <summary>
        /// The event type number of this log. (Table 6; 7.25 of the ELD Final Rule)
        /// </summary>
        [JsonProperty("eventType", Required = Required.Always)]
        public EventType EventType { get; set; }

        /// <summary>
        /// The unique identifier for the specific Entity object in the system.
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// An object with the location information for the log data.
        /// </summary>
        [JsonProperty("location", Required = Required.Always)]
        public string Location { get; set; }

        /// <summary>
        /// The DutyStatusMalfunctionType of the DutyStatusLog record.
        /// </summary>
        [JsonProperty("malfunction", Required = Required.Always)]
        public Malfunction Malfunction { get; set; }

        /// <summary>
        /// Multiday basis (7 or 8) used by the motor carrier to compute cumulative duty hours
        /// </summary>
        [JsonProperty("multidayBasis", Required = Required.Always)]
        public double MultidayBasis { get; set; }

        /// <summary>
        /// The DutyStatusOrigin from where this log originated.
        /// </summary>
        [JsonProperty("origin", Required = Required.Always)]
        public Origin Origin { get; set; }

        /// <summary>
        /// A textual field that may be populated with information pertaining to the creation of an
        /// ELD output file
        /// </summary>
        [JsonProperty("outputFileComment", Required = Required.Always)]
        public string OutputFileComment { get; set; }

        /// <summary>
        /// The Id of the parent DutyStatusLog. Used when a DutyStatusLog is edited. When returning
        /// history, this field will be populated.
        /// </summary>
        [JsonProperty("parentId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ParentId { get; set; }

        /// <summary>
        /// The unique 'Provider ID' of the TSP.
        /// </summary>
        [JsonProperty("providerId", Required = Required.Always)]
        public string ProviderId { get; set; }

        /// <summary>
        /// The sequence number, which is used to generate the sequence ID.
        /// </summary>
        [JsonProperty("sequence", Required = Required.Always)]
        public double Sequence { get; set; }

        /// <summary>
        /// The DutyStatusState of the DutyStatusLog record.
        /// </summary>
        [JsonProperty("state", Required = Required.Always)]
        public State State { get; set; }

        /// <summary>
        /// The DutyStatusLogType representing the driver's duty status.
        /// </summary>
        [JsonProperty("status", Required = Required.Always)]
        public Status Status { get; set; }

        /// <summary>
        /// The vehicle id associated with this log.
        /// </summary>
        [JsonProperty("vehicleId", Required = Required.Always)]
        public string VehicleId { get; set; }

        /// <summary>
        /// The date and time the log was verified. If the log is unverified, this will not be set.
        /// This is the same as log certification. This will be the last certification date.
        /// </summary>
        [JsonProperty("verifyDateTime", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string VerifyDateTime { get; set; }
    }

    public partial class Annotation
    {
        /// <summary>
        /// The annotation text associated with the log.
        /// </summary>
        [JsonProperty("comment", Required = Required.Always)]
        public string Comment { get; set; }

        /// <summary>
        /// Date and time for this annotation log
        /// </summary>
        [JsonProperty("dateTime", Required = Required.Always)]
        public string DateTime { get; set; }

        /// <summary>
        /// The id of the driver who created this log.
        /// </summary>
        [JsonProperty("driverId", Required = Required.Always)]
        public string DriverId { get; set; }

        /// <summary>
        /// The id of this Annotation Log object
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// The unique 'Provider ID' of the TSP.
        /// </summary>
        [JsonProperty("providerId", Required = Required.Always)]
        public string ProviderId { get; set; }
    }

    public partial class VehicleFlaggedEvent
    {
        /// <summary>
        /// vehicle commanded acceleration, in percent
        /// </summary>
        [JsonProperty("accelerationPercent", Required = Required.Always)]
        public double AccelerationPercent { get; set; }

        /// <summary>
        /// the cruise status at the time of this event
        /// </summary>
        [JsonProperty("cruiseStatus", Required = Required.Always)]
        public CruiseStatus CruiseStatus { get; set; }

        /// <summary>
        /// speed of vehicle at time of event, in m/s
        /// </summary>
        [JsonProperty("ecmSpeed", Required = Required.Always)]
        public double EcmSpeed { get; set; }

        /// <summary>
        /// engine RPMs at time of event, in revolutions per minute
        /// </summary>
        [JsonProperty("engineRPM", Required = Required.Always)]
        public double EngineRpm { get; set; }

        /// <summary>
        /// a free-form comment field. Can be used for e.g. identifying the type of event or other
        /// unstructured data
        /// </summary>
        [JsonProperty("eventComment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string EventComment { get; set; }

        /// <summary>
        /// Date and time of the end of the event
        /// </summary>
        [JsonProperty("eventEnd", Required = Required.Always)]
        public string EventEnd { get; set; }

        /// <summary>
        /// Date and time of the start of the event
        /// </summary>
        [JsonProperty("eventStart", Required = Required.Always)]
        public string EventStart { get; set; }

        /// <summary>
        /// vehicle distance traveled since cycled, in m
        /// </summary>
        [JsonProperty("forwardVehicleDistance", Required = Required.Always)]
        public double ForwardVehicleDistance { get; set; }

        /// <summary>
        /// vehicle forward travel elapsed time, in s
        /// </summary>
        [JsonProperty("forwardVehicleElapsed", Required = Required.Always)]
        public double ForwardVehicleElapsed { get; set; }

        /// <summary>
        /// vehicle speed according to tire rotation, in m/s
        /// </summary>
        [JsonProperty("forwardVehicleSpeed", Required = Required.Always)]
        public double ForwardVehicleSpeed { get; set; }

        /// <summary>
        /// heading of vehicle according to GPS at time of event, in degrees
        /// </summary>
        [JsonProperty("gpsHeading", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? GpsHeading { get; set; }

        /// <summary>
        /// the GPS fix quality at the time of this event
        /// </summary>
        [JsonProperty("gpsQuality", Required = Required.AllowNull, NullValueHandling = NullValueHandling.Ignore)]
        public GpsQuality? GpsQuality { get; set; }

        /// <summary>
        /// speed of vehicle at time of event, in m/s
        /// </summary>
        [JsonProperty("gpsSpeed", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? GpsSpeed { get; set; }

        /// <summary>
        /// The unique identifier for the specific Entity object in the system.
        /// </summary>
        [JsonProperty("id", Required = Required.Always)]
        public string Id { get; set; }

        /// <summary>
        /// the ignition status at the time of the event
        /// </summary>
        [JsonProperty("ignitionStatus", Required = Required.Always)]
        public IgnitionStatus IgnitionStatus { get; set; }

        /// <summary>
        /// Odometer reading at time of event, in m
        /// </summary>
        [JsonProperty("odometer", Required = Required.Always)]
        public double Odometer { get; set; }

        /// <summary>
        /// parking break status at time of event
        /// </summary>
        [JsonProperty("parkingBreak", Required = Required.Always)]
        public bool ParkingBreak { get; set; }

        /// <summary>
        /// The unique 'Provider ID' of the TSP.
        /// </summary>
        [JsonProperty("providerId", Required = Required.Always)]
        public string ProviderId { get; set; }

        /// <summary>
        /// Were seat belts engaged at time of event
        /// </summary>
        [JsonProperty("seatBelts", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SeatBelts { get; set; }

        /// <summary>
        /// type flagged event
        /// </summary>
        [JsonProperty("trigger", Required = Required.Always)]
        public Trigger Trigger { get; set; }

        /// <summary>
        /// The vehicle id associated with this event
        /// </summary>
        [JsonProperty("vehicleId", Required = Required.Always)]
        public string VehicleId { get; set; }
    }

    /// <summary>
    /// the cruise status at the time of this event
    /// </summary>
    public partial class CruiseStatus
    {
        /// <summary>
        /// cruise control acceleration switch status at time of event
        /// </summary>
        [JsonProperty("ccAccelerationSwitch", Required = Required.Always)]
        public bool CcAccelerationSwitch { get; set; }

        /// <summary>
        /// cruise control brake switch status at time of event
        /// </summary>
        [JsonProperty("ccBrakeSwitch", Required = Required.Always)]
        public bool CcBrakeSwitch { get; set; }

        /// <summary>
        /// cruise control clutch switch status at time of event
        /// </summary>
        [JsonProperty("ccClutchSwitch", Required = Required.Always)]
        public bool CcClutchSwitch { get; set; }

        /// <summary>
        /// cruise control coast switch status at time of event
        /// </summary>
        [JsonProperty("ccCoastSwitch", Required = Required.Always)]
        public bool CcCoastSwitch { get; set; }

        /// <summary>
        /// cruise control cruise switch status at time of event
        /// </summary>
        [JsonProperty("ccCruiseSwitch", Required = Required.Always)]
        public bool CcCruiseSwitch { get; set; }

        /// <summary>
        /// cruise control resume switch status at time of event
        /// </summary>
        [JsonProperty("ccResumeSwitch", Required = Required.Always)]
        public bool CcResumeSwitch { get; set; }

        /// <summary>
        /// cruise control set switch status at time of event
        /// </summary>
        [JsonProperty("ccSetSwitch", Required = Required.Always)]
        public bool CcSetSwitch { get; set; }

        /// <summary>
        /// cruise control commanded speed at the time of event, in m/s
        /// </summary>
        [JsonProperty("ccSpeed", Required = Required.Always)]
        public double CcSpeed { get; set; }

        /// <summary>
        /// cruise control switch status at time of event
        /// </summary>
        [JsonProperty("ccSwitch", Required = Required.Always)]
        public bool CcSwitch { get; set; }
    }

    /// <summary>
    /// the ignition status at the time of the event
    /// </summary>
    public partial class IgnitionStatus
    {
        /// <summary>
        /// ignition accessory state at time of event
        /// </summary>
        [JsonProperty("ignitionAccessory", Required = Required.Always)]
        public bool IgnitionAccessory { get; set; }

        /// <summary>
        /// ignition aid contact state at time of event
        /// </summary>
        [JsonProperty("ignitionAidContact", Required = Required.Always)]
        public bool IgnitionAidContact { get; set; }

        /// <summary>
        /// ignition crank contact state at time of event
        /// </summary>
        [JsonProperty("ignitionCrankContact", Required = Required.Always)]
        public bool IgnitionCrankContact { get; set; }

        /// <summary>
        /// ignition run contact state at time of event
        /// </summary>
        [JsonProperty("ignitionRunContact", Required = Required.Always)]
        public bool IgnitionRunContact { get; set; }
    }

    /// <summary>
    /// a status variable to indicate if this time history has a higher available resolution at
    /// the TSP
    /// </summary>
    public enum TimeResolution { TimeresolutionMax, TimeresolutionNotMax };

    /// <summary>
    /// The record status number of this log
    /// </summary>
    public enum EventRecordStatus { RecordstatusActive, RecordstatusInactiveToChangeRejected, RecordstatusInactiveToChangeRequested, RecordstatusInactiveToChanged };

    /// <summary>
    /// The event type number of this log. (Table 6; 7.25 of the ELD Final Rule)
    /// </summary>
    public enum EventType { EventtypeCertRecords, EventtypeChangeDutystatus, EventtypeChangePersonalOrYm, EventtypeCmvPowerupdown, EventtypeIntermediateLog, EventtypeLoginoutActivity, EventtypeMalfunctionOrDiagnostic };

    /// <summary>
    /// The DutyStatusMalfunctionType of the DutyStatusLog record.
    /// </summary>
    public enum Malfunction { MalfunctionDiagnostic, MalfunctionDiagnosticmanualposition, MalfunctionMalfunction, MalfunctionMalfunctionmanualposition, MalfunctionManualposition, MalfunctionNone, MalfunctionSystemdiagnosticclear, MalfunctionSystemdiagnosticcleardriving, MalfunctionUserdiagnosticclear, MalfunctionUsermalfunctionclear };

    /// <summary>
    /// The DutyStatusOrigin from where this log originated.
    /// </summary>
    public enum Origin { OriginAutomatic, OriginManual, OriginOtheruser, OriginUnassigned };

    /// <summary>
    /// The DutyStatusState of the DutyStatusLog record.
    /// </summary>
    public enum State { StateActive, StateInactive, StateRejected, StateRequested };

    /// <summary>
    /// The DutyStatusLogType representing the driver's duty status.
    /// </summary>
    public enum Status { StatusAdverseweather, StatusAuthority, StatusCertify, StatusConnected, StatusD, StatusDatarecordingcompliance, StatusDatatransfercompliance, StatusDisconnected, StatusEnginepowerup, StatusEnginepoweruppc, StatusEngineshutdown, StatusEngineshutdownpc, StatusEnginesynccompliance, StatusExemption16H, StatusExemptionoffdutydeferral, StatusIntD, StatusIntPc, StatusLogin, StatusLogoff, StatusMissingelementcompliance, StatusOff, StatusOn, StatusOthercompliance, StatusPc, StatusPositioningcompliance, StatusPowercompliance, StatusSb, StatusSituationaldrivingclear, StatusTimingcompliance, StatusUnidentifieddrivingcompliance, StatusWt, StatusYm };

    /// <summary>
    /// the GPS fix quality at the time of this event
    /// </summary>
    public enum GpsQuality { GpsqualityFinelock, GpsqualityOther };

    /// <summary>
    /// type flagged event
    /// </summary>
    public enum Trigger { FlaggedtypeCollision, FlaggedtypeOnboardRecording, FlaggedtypeRollStability, FlaggedtypeSuddenStart, FlaggedtypeSuddenStop };

    public partial class DriverAvailability
    {
        public static DriverAvailability FromJson(string json) => JsonConvert.DeserializeObject<DriverAvailability>(json, Prototype.OpenTelematics.Models.Converter.Settings1);
    }

    public static partial class Serialize
    {
        public static string ToJson(this DriverAvailability self) => JsonConvert.SerializeObject(self, Prototype.OpenTelematics.Models.Converter.Settings1);
    }

    internal static partial class Converter
    {
        public static readonly JsonSerializerSettings Settings1 = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TimeResolutionConverter.Singleton,
                EventRecordStatusConverter.Singleton,
                EventTypeConverter.Singleton,
                MalfunctionConverter.Singleton,
                OriginConverter.Singleton,
                StateConverter.Singleton,
                StatusConverter.Singleton,
                GpsQualityConverter.Singleton,
                TriggerConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TimeResolutionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TimeResolution) || t == typeof(TimeResolution?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "TIMERESOLUTION_MAX":
                    return TimeResolution.TimeresolutionMax;
                case "TIMERESOLUTION_NOT_MAX":
                    return TimeResolution.TimeresolutionNotMax;
            }
            throw new Exception("Cannot unmarshal type TimeResolution");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TimeResolution)untypedValue;
            switch (value)
            {
                case TimeResolution.TimeresolutionMax:
                    serializer.Serialize(writer, "TIMERESOLUTION_MAX");
                    return;
                case TimeResolution.TimeresolutionNotMax:
                    serializer.Serialize(writer, "TIMERESOLUTION_NOT_MAX");
                    return;
            }
            throw new Exception("Cannot marshal type TimeResolution");
        }

        public static readonly TimeResolutionConverter Singleton = new TimeResolutionConverter();
    }

    internal class EventRecordStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EventRecordStatus) || t == typeof(EventRecordStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "RECORDSTATUS_ACTIVE":
                    return EventRecordStatus.RecordstatusActive;
                case "RECORDSTATUS_INACTIVE_TO_CHANGED":
                    return EventRecordStatus.RecordstatusInactiveToChanged;
                case "RECORDSTATUS_INACTIVE_TO_CHANGE_REJECTED":
                    return EventRecordStatus.RecordstatusInactiveToChangeRejected;
                case "RECORDSTATUS_INACTIVE_TO_CHANGE_REQUESTED":
                    return EventRecordStatus.RecordstatusInactiveToChangeRequested;
            }
            throw new Exception("Cannot unmarshal type EventRecordStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EventRecordStatus)untypedValue;
            switch (value)
            {
                case EventRecordStatus.RecordstatusActive:
                    serializer.Serialize(writer, "RECORDSTATUS_ACTIVE");
                    return;
                case EventRecordStatus.RecordstatusInactiveToChanged:
                    serializer.Serialize(writer, "RECORDSTATUS_INACTIVE_TO_CHANGED");
                    return;
                case EventRecordStatus.RecordstatusInactiveToChangeRejected:
                    serializer.Serialize(writer, "RECORDSTATUS_INACTIVE_TO_CHANGE_REJECTED");
                    return;
                case EventRecordStatus.RecordstatusInactiveToChangeRequested:
                    serializer.Serialize(writer, "RECORDSTATUS_INACTIVE_TO_CHANGE_REQUESTED");
                    return;
            }
            throw new Exception("Cannot marshal type EventRecordStatus");
        }

        public static readonly EventRecordStatusConverter Singleton = new EventRecordStatusConverter();
    }

    internal class EventTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EventType) || t == typeof(EventType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EVENTTYPE_CERT_RECORDS":
                    return EventType.EventtypeCertRecords;
                case "EVENTTYPE_CHANGE_DUTYSTATUS":
                    return EventType.EventtypeChangeDutystatus;
                case "EVENTTYPE_CHANGE_PERSONAL_OR_YM":
                    return EventType.EventtypeChangePersonalOrYm;
                case "EVENTTYPE_CMV_POWERUPDOWN":
                    return EventType.EventtypeCmvPowerupdown;
                case "EVENTTYPE_INTERMEDIATE_LOG":
                    return EventType.EventtypeIntermediateLog;
                case "EVENTTYPE_LOGINOUT_ACTIVITY":
                    return EventType.EventtypeLoginoutActivity;
                case "EVENTTYPE_MALFUNCTION_OR_DIAGNOSTIC":
                    return EventType.EventtypeMalfunctionOrDiagnostic;
            }
            throw new Exception("Cannot unmarshal type EventType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EventType)untypedValue;
            switch (value)
            {
                case EventType.EventtypeCertRecords:
                    serializer.Serialize(writer, "EVENTTYPE_CERT_RECORDS");
                    return;
                case EventType.EventtypeChangeDutystatus:
                    serializer.Serialize(writer, "EVENTTYPE_CHANGE_DUTYSTATUS");
                    return;
                case EventType.EventtypeChangePersonalOrYm:
                    serializer.Serialize(writer, "EVENTTYPE_CHANGE_PERSONAL_OR_YM");
                    return;
                case EventType.EventtypeCmvPowerupdown:
                    serializer.Serialize(writer, "EVENTTYPE_CMV_POWERUPDOWN");
                    return;
                case EventType.EventtypeIntermediateLog:
                    serializer.Serialize(writer, "EVENTTYPE_INTERMEDIATE_LOG");
                    return;
                case EventType.EventtypeLoginoutActivity:
                    serializer.Serialize(writer, "EVENTTYPE_LOGINOUT_ACTIVITY");
                    return;
                case EventType.EventtypeMalfunctionOrDiagnostic:
                    serializer.Serialize(writer, "EVENTTYPE_MALFUNCTION_OR_DIAGNOSTIC");
                    return;
            }
            throw new Exception("Cannot marshal type EventType");
        }

        public static readonly EventTypeConverter Singleton = new EventTypeConverter();
    }

    internal class MalfunctionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Malfunction) || t == typeof(Malfunction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MALFUNCTION_DIAGNOSTIC":
                    return Malfunction.MalfunctionDiagnostic;
                case "MALFUNCTION_DIAGNOSTICMANUALPOSITION":
                    return Malfunction.MalfunctionDiagnosticmanualposition;
                case "MALFUNCTION_MALFUNCTION":
                    return Malfunction.MalfunctionMalfunction;
                case "MALFUNCTION_MALFUNCTIONMANUALPOSITION":
                    return Malfunction.MalfunctionMalfunctionmanualposition;
                case "MALFUNCTION_MANUALPOSITION":
                    return Malfunction.MalfunctionManualposition;
                case "MALFUNCTION_NONE":
                    return Malfunction.MalfunctionNone;
                case "MALFUNCTION_SYSTEMDIAGNOSTICCLEAR":
                    return Malfunction.MalfunctionSystemdiagnosticclear;
                case "MALFUNCTION_SYSTEMDIAGNOSTICCLEARDRIVING":
                    return Malfunction.MalfunctionSystemdiagnosticcleardriving;
                case "MALFUNCTION_USERDIAGNOSTICCLEAR":
                    return Malfunction.MalfunctionUserdiagnosticclear;
                case "MALFUNCTION_USERMALFUNCTIONCLEAR":
                    return Malfunction.MalfunctionUsermalfunctionclear;
            }
            throw new Exception("Cannot unmarshal type Malfunction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Malfunction)untypedValue;
            switch (value)
            {
                case Malfunction.MalfunctionDiagnostic:
                    serializer.Serialize(writer, "MALFUNCTION_DIAGNOSTIC");
                    return;
                case Malfunction.MalfunctionDiagnosticmanualposition:
                    serializer.Serialize(writer, "MALFUNCTION_DIAGNOSTICMANUALPOSITION");
                    return;
                case Malfunction.MalfunctionMalfunction:
                    serializer.Serialize(writer, "MALFUNCTION_MALFUNCTION");
                    return;
                case Malfunction.MalfunctionMalfunctionmanualposition:
                    serializer.Serialize(writer, "MALFUNCTION_MALFUNCTIONMANUALPOSITION");
                    return;
                case Malfunction.MalfunctionManualposition:
                    serializer.Serialize(writer, "MALFUNCTION_MANUALPOSITION");
                    return;
                case Malfunction.MalfunctionNone:
                    serializer.Serialize(writer, "MALFUNCTION_NONE");
                    return;
                case Malfunction.MalfunctionSystemdiagnosticclear:
                    serializer.Serialize(writer, "MALFUNCTION_SYSTEMDIAGNOSTICCLEAR");
                    return;
                case Malfunction.MalfunctionSystemdiagnosticcleardriving:
                    serializer.Serialize(writer, "MALFUNCTION_SYSTEMDIAGNOSTICCLEARDRIVING");
                    return;
                case Malfunction.MalfunctionUserdiagnosticclear:
                    serializer.Serialize(writer, "MALFUNCTION_USERDIAGNOSTICCLEAR");
                    return;
                case Malfunction.MalfunctionUsermalfunctionclear:
                    serializer.Serialize(writer, "MALFUNCTION_USERMALFUNCTIONCLEAR");
                    return;
            }
            throw new Exception("Cannot marshal type Malfunction");
        }

        public static readonly MalfunctionConverter Singleton = new MalfunctionConverter();
    }

    internal class OriginConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Origin) || t == typeof(Origin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ORIGIN_AUTOMATIC":
                    return Origin.OriginAutomatic;
                case "ORIGIN_MANUAL":
                    return Origin.OriginManual;
                case "ORIGIN_OTHERUSER":
                    return Origin.OriginOtheruser;
                case "ORIGIN_UNASSIGNED":
                    return Origin.OriginUnassigned;
            }
            throw new Exception("Cannot unmarshal type Origin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Origin)untypedValue;
            switch (value)
            {
                case Origin.OriginAutomatic:
                    serializer.Serialize(writer, "ORIGIN_AUTOMATIC");
                    return;
                case Origin.OriginManual:
                    serializer.Serialize(writer, "ORIGIN_MANUAL");
                    return;
                case Origin.OriginOtheruser:
                    serializer.Serialize(writer, "ORIGIN_OTHERUSER");
                    return;
                case Origin.OriginUnassigned:
                    serializer.Serialize(writer, "ORIGIN_UNASSIGNED");
                    return;
            }
            throw new Exception("Cannot marshal type Origin");
        }

        public static readonly OriginConverter Singleton = new OriginConverter();
    }

    internal class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(State) || t == typeof(State?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "STATE_ACTIVE":
                    return State.StateActive;
                case "STATE_INACTIVE":
                    return State.StateInactive;
                case "STATE_REJECTED":
                    return State.StateRejected;
                case "STATE_REQUESTED":
                    return State.StateRequested;
            }
            throw new Exception("Cannot unmarshal type State");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (State)untypedValue;
            switch (value)
            {
                case State.StateActive:
                    serializer.Serialize(writer, "STATE_ACTIVE");
                    return;
                case State.StateInactive:
                    serializer.Serialize(writer, "STATE_INACTIVE");
                    return;
                case State.StateRejected:
                    serializer.Serialize(writer, "STATE_REJECTED");
                    return;
                case State.StateRequested:
                    serializer.Serialize(writer, "STATE_REQUESTED");
                    return;
            }
            throw new Exception("Cannot marshal type State");
        }

        public static readonly StateConverter Singleton = new StateConverter();
    }

    internal class StatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Status) || t == typeof(Status?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "STATUS_ADVERSEWEATHER":
                    return Status.StatusAdverseweather;
                case "STATUS_AUTHORITY":
                    return Status.StatusAuthority;
                case "STATUS_CERTIFY":
                    return Status.StatusCertify;
                case "STATUS_CONNECTED":
                    return Status.StatusConnected;
                case "STATUS_D":
                    return Status.StatusD;
                case "STATUS_DATARECORDINGCOMPLIANCE":
                    return Status.StatusDatarecordingcompliance;
                case "STATUS_DATATRANSFERCOMPLIANCE":
                    return Status.StatusDatatransfercompliance;
                case "STATUS_DISCONNECTED":
                    return Status.StatusDisconnected;
                case "STATUS_ENGINEPOWERUP":
                    return Status.StatusEnginepowerup;
                case "STATUS_ENGINEPOWERUPPC":
                    return Status.StatusEnginepoweruppc;
                case "STATUS_ENGINESHUTDOWN":
                    return Status.StatusEngineshutdown;
                case "STATUS_ENGINESHUTDOWNPC":
                    return Status.StatusEngineshutdownpc;
                case "STATUS_ENGINESYNCCOMPLIANCE":
                    return Status.StatusEnginesynccompliance;
                case "STATUS_EXEMPTION16H":
                    return Status.StatusExemption16H;
                case "STATUS_EXEMPTIONOFFDUTYDEFERRAL":
                    return Status.StatusExemptionoffdutydeferral;
                case "STATUS_INT_D":
                    return Status.StatusIntD;
                case "STATUS_INT_PC":
                    return Status.StatusIntPc;
                case "STATUS_LOGIN":
                    return Status.StatusLogin;
                case "STATUS_LOGOFF":
                    return Status.StatusLogoff;
                case "STATUS_MISSINGELEMENTCOMPLIANCE":
                    return Status.StatusMissingelementcompliance;
                case "STATUS_OFF":
                    return Status.StatusOff;
                case "STATUS_ON":
                    return Status.StatusOn;
                case "STATUS_OTHERCOMPLIANCE":
                    return Status.StatusOthercompliance;
                case "STATUS_PC":
                    return Status.StatusPc;
                case "STATUS_POSITIONINGCOMPLIANCE":
                    return Status.StatusPositioningcompliance;
                case "STATUS_POWERCOMPLIANCE":
                    return Status.StatusPowercompliance;
                case "STATUS_SB":
                    return Status.StatusSb;
                case "STATUS_SITUATIONALDRIVINGCLEAR":
                    return Status.StatusSituationaldrivingclear;
                case "STATUS_TIMINGCOMPLIANCE":
                    return Status.StatusTimingcompliance;
                case "STATUS_UNIDENTIFIEDDRIVINGCOMPLIANCE":
                    return Status.StatusUnidentifieddrivingcompliance;
                case "STATUS_WT":
                    return Status.StatusWt;
                case "STATUS_YM":
                    return Status.StatusYm;
            }
            throw new Exception("Cannot unmarshal type Status");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Status)untypedValue;
            switch (value)
            {
                case Status.StatusAdverseweather:
                    serializer.Serialize(writer, "STATUS_ADVERSEWEATHER");
                    return;
                case Status.StatusAuthority:
                    serializer.Serialize(writer, "STATUS_AUTHORITY");
                    return;
                case Status.StatusCertify:
                    serializer.Serialize(writer, "STATUS_CERTIFY");
                    return;
                case Status.StatusConnected:
                    serializer.Serialize(writer, "STATUS_CONNECTED");
                    return;
                case Status.StatusD:
                    serializer.Serialize(writer, "STATUS_D");
                    return;
                case Status.StatusDatarecordingcompliance:
                    serializer.Serialize(writer, "STATUS_DATARECORDINGCOMPLIANCE");
                    return;
                case Status.StatusDatatransfercompliance:
                    serializer.Serialize(writer, "STATUS_DATATRANSFERCOMPLIANCE");
                    return;
                case Status.StatusDisconnected:
                    serializer.Serialize(writer, "STATUS_DISCONNECTED");
                    return;
                case Status.StatusEnginepowerup:
                    serializer.Serialize(writer, "STATUS_ENGINEPOWERUP");
                    return;
                case Status.StatusEnginepoweruppc:
                    serializer.Serialize(writer, "STATUS_ENGINEPOWERUPPC");
                    return;
                case Status.StatusEngineshutdown:
                    serializer.Serialize(writer, "STATUS_ENGINESHUTDOWN");
                    return;
                case Status.StatusEngineshutdownpc:
                    serializer.Serialize(writer, "STATUS_ENGINESHUTDOWNPC");
                    return;
                case Status.StatusEnginesynccompliance:
                    serializer.Serialize(writer, "STATUS_ENGINESYNCCOMPLIANCE");
                    return;
                case Status.StatusExemption16H:
                    serializer.Serialize(writer, "STATUS_EXEMPTION16H");
                    return;
                case Status.StatusExemptionoffdutydeferral:
                    serializer.Serialize(writer, "STATUS_EXEMPTIONOFFDUTYDEFERRAL");
                    return;
                case Status.StatusIntD:
                    serializer.Serialize(writer, "STATUS_INT_D");
                    return;
                case Status.StatusIntPc:
                    serializer.Serialize(writer, "STATUS_INT_PC");
                    return;
                case Status.StatusLogin:
                    serializer.Serialize(writer, "STATUS_LOGIN");
                    return;
                case Status.StatusLogoff:
                    serializer.Serialize(writer, "STATUS_LOGOFF");
                    return;
                case Status.StatusMissingelementcompliance:
                    serializer.Serialize(writer, "STATUS_MISSINGELEMENTCOMPLIANCE");
                    return;
                case Status.StatusOff:
                    serializer.Serialize(writer, "STATUS_OFF");
                    return;
                case Status.StatusOn:
                    serializer.Serialize(writer, "STATUS_ON");
                    return;
                case Status.StatusOthercompliance:
                    serializer.Serialize(writer, "STATUS_OTHERCOMPLIANCE");
                    return;
                case Status.StatusPc:
                    serializer.Serialize(writer, "STATUS_PC");
                    return;
                case Status.StatusPositioningcompliance:
                    serializer.Serialize(writer, "STATUS_POSITIONINGCOMPLIANCE");
                    return;
                case Status.StatusPowercompliance:
                    serializer.Serialize(writer, "STATUS_POWERCOMPLIANCE");
                    return;
                case Status.StatusSb:
                    serializer.Serialize(writer, "STATUS_SB");
                    return;
                case Status.StatusSituationaldrivingclear:
                    serializer.Serialize(writer, "STATUS_SITUATIONALDRIVINGCLEAR");
                    return;
                case Status.StatusTimingcompliance:
                    serializer.Serialize(writer, "STATUS_TIMINGCOMPLIANCE");
                    return;
                case Status.StatusUnidentifieddrivingcompliance:
                    serializer.Serialize(writer, "STATUS_UNIDENTIFIEDDRIVINGCOMPLIANCE");
                    return;
                case Status.StatusWt:
                    serializer.Serialize(writer, "STATUS_WT");
                    return;
                case Status.StatusYm:
                    serializer.Serialize(writer, "STATUS_YM");
                    return;
            }
            throw new Exception("Cannot marshal type Status");
        }

        public static readonly StatusConverter Singleton = new StatusConverter();
    }

    internal class GpsQualityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GpsQuality) || t == typeof(GpsQuality?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "GPSQUALITY_FINELOCK":
                    return GpsQuality.GpsqualityFinelock;
                case "GPSQUALITY_OTHER":
                    return GpsQuality.GpsqualityOther;
            }
            throw new Exception("Cannot unmarshal type GpsQuality");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GpsQuality)untypedValue;
            switch (value)
            {
                case GpsQuality.GpsqualityFinelock:
                    serializer.Serialize(writer, "GPSQUALITY_FINELOCK");
                    return;
                case GpsQuality.GpsqualityOther:
                    serializer.Serialize(writer, "GPSQUALITY_OTHER");
                    return;
            }
            throw new Exception("Cannot marshal type GpsQuality");
        }

        public static readonly GpsQualityConverter Singleton = new GpsQualityConverter();
    }

    internal class TriggerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Trigger) || t == typeof(Trigger?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FLAGGEDTYPE_COLLISION":
                    return Trigger.FlaggedtypeCollision;
                case "FLAGGEDTYPE_ONBOARD_RECORDING":
                    return Trigger.FlaggedtypeOnboardRecording;
                case "FLAGGEDTYPE_ROLL_STABILITY":
                    return Trigger.FlaggedtypeRollStability;
                case "FLAGGEDTYPE_SUDDEN_START":
                    return Trigger.FlaggedtypeSuddenStart;
                case "FLAGGEDTYPE_SUDDEN_STOP":
                    return Trigger.FlaggedtypeSuddenStop;
            }
            throw new Exception("Cannot unmarshal type Trigger");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Trigger)untypedValue;
            switch (value)
            {
                case Trigger.FlaggedtypeCollision:
                    serializer.Serialize(writer, "FLAGGEDTYPE_COLLISION");
                    return;
                case Trigger.FlaggedtypeOnboardRecording:
                    serializer.Serialize(writer, "FLAGGEDTYPE_ONBOARD_RECORDING");
                    return;
                case Trigger.FlaggedtypeRollStability:
                    serializer.Serialize(writer, "FLAGGEDTYPE_ROLL_STABILITY");
                    return;
                case Trigger.FlaggedtypeSuddenStart:
                    serializer.Serialize(writer, "FLAGGEDTYPE_SUDDEN_START");
                    return;
                case Trigger.FlaggedtypeSuddenStop:
                    serializer.Serialize(writer, "FLAGGEDTYPE_SUDDEN_STOP");
                    return;
            }
            throw new Exception("Cannot marshal type Trigger");
        }

        public static readonly TriggerConverter Singleton = new TriggerConverter();
    }
}
